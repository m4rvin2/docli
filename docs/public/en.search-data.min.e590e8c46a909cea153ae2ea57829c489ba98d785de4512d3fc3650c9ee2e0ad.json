[{"id":0,"href":"/docs/feedback/","title":"Feedback","section":"Docs","content":"Feedback #  Feel free to send me feedback on Twitter or file an issue. Feature requests and contributions are always welcome.\n"},{"id":1,"href":"/docs/installation/","title":"Installation","section":"Docs","content":"Installation #  You can install Docli with a single command using go get, the Go package manager. Type this into your terminal:\n$ go get -u github.com/celicoo/docli/v2@latest Don\u0026rsquo;t have Go installed? Learn how to install Go here.\n"},{"id":2,"href":"/docs/tutorial/","title":"Tutorial","section":"Docs","content":"Tutorial #  Welcome to the Docli Tutorial! Here you\u0026rsquo;ll be introduced to the key Docli concepts. If you get stuck at any point in the process, feel free to download a working example of the completed CLI app.\nConfirming that Docli is installed #  Before starting the tutorial, let\u0026rsquo;s make sure that you have Docli installed. Go ahead and create a main.go file and paste the following content inside:\npackage main import ( \u0026#34;github.com/alecthomas/repr\u0026#34; \u0026#34;github.com/celicoo/docli\u0026#34; ) func main() { args := docli.Args() repr.Println(args) } Now build and run it:\n$ go build $ ./main docli.args{ } Note: the output is the Abstract Syntax Structure of the command-line arguments, and it\u0026rsquo;s empty because you didn\u0026rsquo;t pass any arguments. If you run it again passing arguments you should see a different output.\nCreating a new CLI app #  Directory structure #  If you like Cobra, you\u0026rsquo;ll feel at home with this. While you\u0026rsquo;re welcome to provide your own organization, typically a Docli-based app will follow the following directory structure:\n▾ app/ ▾ cmd/ root.go main.go Go ahead and create the above structure, but instead of app, let\u0026rsquo;s name the root directory to git.\napp/ #  This is the root of our app. The main.go file goes into this directory and it\u0026rsquo;s responsible for calling the function that initializes Docli:\npackage main import \u0026#34;\u0026lt;path\u0026gt;/git\u0026#34; func main() { cmd.Execute() } Note: Make sure to replace the \u0026lt;path\u0026gt; placeholder.\ncmd/ #  This is where the commands are stored. The root.go is responsible for the logic of the root command and the Execute() function:\npackage cmd const version = \u0026#34;0.0.1\u0026#34; type Git struct {} func (g *Git) Doc() string { return \u0026#34;\u0026#34; } func (g *Git) Run() { } func (g *Git) Help() { } func (g *Git) Error(err error) { } func Execute() { } The Git struct represents the root command in our CLI app and it must implement the docli.command interface.\nWriting the docstring #  Like YAML or Python, the docstring is a line-oriented language that uses indentation to define structure. Lines beginning with either spaces or tabs are used to register arguments and commands (commands are explained a little later in the tutorial). These arguments and commands can have letters of any language, numbers, and dashes.\nLet’s go back to the root.go file and replace the Doc() method of our Git struct with:\nfunc (g *Git) Doc() string { return `usage: git \u0026lt;command\u0026gt; commands: c, clone clone a repository into a new directory arguments: v, --version print version Use \u0026#34;git \u0026lt;command\u0026gt; help\u0026#34; for more information about the \u0026lt;command\u0026gt;.` } By convention, dashes are used in front of arguments, but not commands. You can use this convention with Docli, but it\u0026rsquo;s not necessary.\nAccessing command-line argument values #  Now that we’ve registered the arguments and commands in the docstring, we’ll need to define them as fields in the Git struct, so we can access their values. Fields that represent arguments will be primitive types and those that represent commands will be user-defined types that implement the docli.command interface, just like the root command does.\nRegardless of how many aliases your arguments or commands have , you\u0026rsquo;ll only need to (and only should) define one field in the struct. We suggest using the longer identifier, but you can use whichever you’d like.\nIn our example, we have one command and one argument, and each has two identifiers. Let’s add these to our Git struct:\ntype Git struct { Clone Clone Version bool } For every command, you’ll need to create a file to hold the type that represents the command. In our example, the Clone field represents the clone command, so we need to create a file that holds this type. Let\u0026rsquo;s go ahead and create the clone.go file inside the cmd directory and paste the following code inside:\npackage cmd import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/alecthomas/repr\u0026#34; ) type Clone struct { Repository, Directory string Verbose, Quiet, Progress, NoCheckout, Bare, Mirror, Local, NoHardlinks, Shared bool RecurseSubmodules string Jobs int Template, Reference, ReferenceIfAble string Dissociate bool Origin, Branch, UploadPack string Depth int ShallowSince, ShallowExclude string SingleBranch, NoTags, ShallowSubmodules bool SeparateGitDir, Config string Ipv4, Ipv6 bool Filter string } func (c *Clone) Doc() string { return `usage: git clone [\u0026lt;arguments\u0026gt;] --repository=\u0026lt;url\u0026gt; --directory=\u0026lt;directory\u0026gt; arguments: -r, --repository repository to clone -d, --directory path to directory -v, --verbose be more verbose -q, --quiet be more quiet --progress force progress reporting -n, --no-checkout don\u0026#39;t create a checkout --bare create a bare repository --mirror create a mirror repository (implies bare) -l, --local to clone from a local repository --no-hardlinks don\u0026#39;t use local hardlinks, always copy -s, --shared setup as shared repository --recurse-submodules=\u0026lt;pathspec\u0026gt; initialize submodules in the clone -j, --jobs=\u0026lt;n\u0026gt; number of submodules cloned in parallel --template=\u0026lt;template-directory\u0026gt; directory from which templates will be used --reference=\u0026lt;repo\u0026gt; reference repository --reference-if-able=\u0026lt;repo\u0026gt; reference repository --dissociate use --reference only while cloning -o, --origin=\u0026lt;name\u0026gt; use \u0026lt;name\u0026gt; instead of \u0026#39;origin\u0026#39; to track upstream -b, --branch=\u0026lt;branch\u0026gt; checkout \u0026lt;branch\u0026gt; instead of the remote\u0026#39;s HEAD -u, --upload-pack=\u0026lt;path\u0026gt; path to git-upload-pack on the remote --depth=\u0026lt;depth\u0026gt; create a shallow clone of that depth --shallow-since=\u0026lt;time\u0026gt; create a shallow clone since a specific time --shallow-exclude=\u0026lt;revision\u0026gt; deepen history of shallow clone, excluding rev --single-branch clone only one branch, HEAD or --branch --no-tags don\u0026#39;t clone any tags, and make later fetches not to follow them --shallow-submodules any cloned submodules will be shallow --separate-git-dir=\u0026lt;gitdir\u0026gt; separate git dir from working tree -c, --config=\u0026lt;key=value\u0026gt; set config inside the new repository -4, --ipv4 use IPv4 addresses only -6, --ipv6 use IPv6 addresses only --filter=\u0026lt;args\u0026gt; object filtering ` } func (c *Clone) Run() { repr.Println(c) } func (c *Clone) Help() { fmt.Println(c.Doc()) } func (c *Clone) Error(err error) { log.Fatal(err) } In this tutorial, we won’t go into detail about the logic of the Clone command because its functionality is pretty straightforward.\nWriting the Methods’ Logic #  A specific method will run when a certain condition is met.\nError method #  The Error method will run when the user passes an argument or command that is not registered in the docstring. Usually, you\u0026rsquo;ll just print the error message to stderr and exit the program. In our example, we\u0026rsquo;ll ignore invalid arguments and force the Run method to run, otherwise we\u0026rsquo;ll print the error message to stderr and exit the program:\nfunc (g *Git) Error(err error) { switch err.(type) { case *args.InvalidArgumentError: // Ignore InvalidArgumentError. \tg.Run() default: log.Fatal(err) } } The InvalidArgumentError is within the args package, so make sure to add \u0026quot;github.com/celicoo/docli/args\u0026quot; to the import declarations.\nHelp method #  The Help method will run when the user passes the help argument. Usually, you\u0026rsquo;ll just print the docstring to stdout; that’s what we’ll do in our example:\nfunc (g *Git) Help() { fmt.Println(g.Doc()) } Run method #  The Run method will run when no error is found and an argument other than help is called. In our example we\u0026rsquo;ll print the version if the --version (or -v) command-line argument is passed, otherwise we\u0026rsquo;ll just print \u0026ldquo;Hello, world!\u0026quot;:\nfunc (g *Git) Run() { if g.Version { fmt.Println(version) return } fmt.Println(\u0026#34;Hello, world!\u0026#34;) } Initializing Docli #  We created a CLI app with one command and one argument. But if you try to execute it, it won’t run. There is one piece missing: initializing Docli.\nfunc Execute() { var g Git args := docli.Args() args.Bind(\u0026amp;g) } Testing the CLI app #  The very last step is to make sure it’s actually working. To do that, we need to build and run it:\n$ go build $ ./git Hello, world! Unlike other packages, Docli doesn\u0026rsquo;t allow values to be assigned to arguments without using the = operator. You need to use the = operator, otherwise the internal parser will think you’re passing an argument and, as a result, the Error method of the struct that represents the command that you\u0026rsquo;re executing will be called. The clone command was added to help you understand this, so go ahead and play with it.\nCongratulations! You’ve completed the tutorial. Thank you for reading, and I hope you enjoyed it.\nIf you have any question, please don’t hesitate to open an issue.\n"},{"id":3,"href":"/docs/unsupported-features/","title":"Unsupported features","section":"Docs","content":"Unsupported features #  Right now, Docli doesn\u0026rsquo;t support the following features:\n Bash autocomplete Default values Global arguments Intelligent suggestions Positional arguments  If you absolutely need either one of those features, we recommend these alternative libraries.\n"}]